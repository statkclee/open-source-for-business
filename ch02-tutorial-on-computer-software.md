---
layout: page
title: 비즈니스를 위한 오픈 소스 소프트웨어 한국어 번역
subtitle: 2장 컴퓨터 소프트웨어 과외
---


컴퓨터 엔지니어가 아니고 오픈소스 라이선스 사용허가권을 이해하는데 유용한 개념을 잡으려고 하는 독자를 위한 과외학습내용이 나와 있다.

### 오픈 소스의 "소스"가 무엇인가?

요즘 언론에 따르면 적어도 모든 것이 오픈 소스(Open Source)다 - 몇가지 사례를 들면, 교과서, 요가, 윤월절(seders), 농사 씨앗, 데이터베이스, 곤충 농장 조립용품 세트. 이 모든 것들이 "오픈(Open)"되었지만, 정말 어떤 소스코드(source code)도 없다. 왜 오픈소스가 중요한지 이해하기 위해서는, 먼저 소스코드(bug farm kit)가 무엇인지 이해해야만 된다.

오늘날 대부분의 컴퓨터 사용자는 (a) iOS 혹은 안드로이스 시스템을 탑재한 모바일 기기를 사용하거나 (b) 윈도우즈 운영체제를 탑재한 데스크톱 혹은 노트북 컴퓨터를 사용한다. 모바일 기기나 컴퓨터에 있는 프로그램을 실행할 때 (*앱(App)*, 응용프로그램), 프로그램을 구성하는 전자파일을 *실행가능한 파일(executable file)*이라고 부른다. 본인 컴퓨터에 다른 것과 마찬가지로 파일이지만, 컴퓨터가 실행할 수 있는 형식(format)으로 되어 있다. 윈도우즈 데스크톱 시스템에서, 이러한 파일은 파일 확장자로 "실행가능(executable)"을 뜻하는 `.exe`를 갖는다. (모바일 플랫폼에서는 이런 파일을 전혀 볼 수 없지만, 응용프로그램 각각이 실행가능한 파일이다.)

컴퓨터는 복잡한 연산작업을 중앙처리장치 혹은 그래픽 처리장치가 초당 수십억번 수행할 수 있는 매우 작은 단계로 연산작업을 쪼개서 수행한다. 1 바이트를 4바이트로 기억장치 특정 장소에서 다른 장소로 이동, 단순한 사칙연산 수행, 실행할 다음 단계를 선택하는 작업(디폴트 기본설정 혹은 테스트 결과에 따라)이 이러한 연산작업에 포함된다. 각 연산작업은 매우 단순하지만, 아주 많은 연산작업을 수행함으로써, 컴퓨터는 사람이 인지할 수 있는 행동을 취할 수 있다 - 예를 들어, 화면에 메시지 출력. 컴퓨터가 이해할 수 있는 단순한 명령은 너무 작은 조각이라 사람이 쉽게 이해하고 조직화할 수 없다. 그래서, 컴퓨터 과학자가 컴퓨터 프로그램을 작성하는데 사용되는 컴퓨터 언어를 개발해서 사람이 더 쉽게 처리할 수 있게 했다. 이것이 소위 프로그래밍 언어(Programming Language)다. 프로그래밍 언어 각 문장이 많은 컴퓨터 명령으로 번역된다.

사람이 프로그램을 *소스코드*로 표현한다. 컴퓨터는 소스코드를 *컴파일(Compilation)*과 *해석(interpretation)*으로 불리는 과정을 거쳐 실행될 수 있는 무언가로 번역한다. 예를 들어, 대부분의 C 프로그램은 CPU로 직접 실행될 수 있는 이진코드로 컴파일된다. 자바와 마이크로소프트 C#으로 작성된 프로그램은 *바이트 코드(byte code)*로 불리는 중간 이진표현으로 번역되고, *가상 컴퓨터(Virtual Machine)*으로 불리는 컴퓨터 프로그램에 의해서 실행되는 이진코드로 전환된다. 

C와 자바같은 많은 프로그래밍 언어는 소스코드 형태와 실행가능 형태를 갖고 있다. 소스코드 형태는 실행가능하지 않다. 컴퓨터가 실행할 수 없다는 의미다. 실행가능 형태는 사람이 읽을 수가 없다 - 본질적으로 수많은 0과 1로 구성되어 있고, 종종 *목적 형태(object form)*라고도 불린다.

소프트웨어를 작성하는데 컴퓨터 언어 프로그래머가 소스코드를 사용한다. 소스코드는 거의 [자연어][1]처럼 생겼다. 다음에 예제가 있다.

~~~ {.input}
#include <stdio.h>
int main(void)
  {
    int x; 
    x=1;
    if (x==1) {printf ("I am the One.\n")};
    return 0;
  }
~~~

상기 언어가 프로그래머가 아닌 일반인에게 이상하게 보일 수도 있지만, 일부는 친숙해야 된다. 컴퓨터 언어는 *include* 혹은 *print* 같은 동사, *x* 같은 명사, *int* (integer 정수를 나타냄) 같은 형용사를 갖고 있다. 프로그래머가 사용하고자 하는 코드를 작성하고 나서, 텍스트로 파일을 저장한다. 그리고 나서 *컴파일러(compiler)*라고 불리는 프로그램을 실행한다. 컴파일러는 텍스트파일을 소스코드로 처리하고 소스코드를 목적코드(object code)로 번역한다. 코드가 목적 형태로 되면, 소스코드로 되돌아 가지 않고는 변경될 수 없다. 이론적으로 코드를 "역컴파일(decompile)"할 수 있지만, 과정이 그다지 신뢰성이 있지 않고, 어떤 상황에서도 역컴파일된 코드는 소스코드를 좀더 읽기 좋게 만드는 주석이 포함되어 있지 않다. 사실 역컴파일에 관한 진실은 복잡하다: 자바같은 일부 언어는 믿음직스럽게 역컴파일되는 반면에 C 같은 다른 언어는 그렇지 못하다; 그리고 역컴파일러는 매년 정확성이 높아지고 정교화되고 있다. 

컴퓨터가 더 느렸을 때, 프로그램을 소스코드에서 실행가능 형태로 전환하는 시간은 측정가능했고, 사용자의 프로그램 사용을 방해하거나 늦췄다. 지난 20년에 걸쳐서, CPU는 훨씬 빨라졌다. 처리가 더 빨라짐에 따라, 더 많은 연산작업이 메인 프로그램에서 라이브러리로 옮겨졌다. 예를 들어, 애플 II 시절에  개발자가 코드를 작성하려고 하면 이미지를 화면 주위로 옮겨야 했다. 오늘날, 소스코드 한줄로 웹브라우져에서 이미지 애니메이션 기능을 구현하는 방법은 수도 없이 많다.

[1]: (컴퓨터 언어에 반대되어) 자연어로 사람이 사용하는 언어다; 영어와 한국어가 좋은 사례다.

이와 같은 발전으로, 코드가 점차 소스코드 형태로 배포된다. 예를 들어, 웹브라우져에 HTML과 자바스크립트를 적재되면, 웹브라우져가 웹페이지를 화면에 출력하고, 입력값을 검사하고, 페이지 콘텐츠에 애니메이션할 수 있는 실행가능한 코드로 HTML과 자바스크립트를 변환한다. 오늘날 일반적인 웹페이지는 20년 전 컴퓨터 전체 메모리에 넣을 수는 것보다 많은 코드를 담고 있다.

인터넷으로 코드를 전송하는데 소요되는 시간을 줄이고자, 프로그래머가 코드를 더 작게 압축한다. 이렇게 압축된 코드는 기술적으로 중간 형태가 아닐 수도 있지만, 원시 소스코드와 다르게 보인다. 따라서, 웹브라우져 내부에서 실행되는 (이점에 대해서 아래를 좀더 참조) 자바스크립트는 흔히 모든 화이트스페이스(white space)를 삭제하도록 변형된다. 프로그래밍에서, 공백과 탭 같은 *화이트스페이스*는 일반적으로 기능이 없고 단지 가독성을 높이기 위해서 사용된다. 따라서 화이트스페이스를 삭제하게 되면 기능적으로 동일한 읽기에 매우 촘촘한 소스코드가 된다. 따라서, 상기 예제코드는 다음과 같이 다시 작성될 수 있다:

~~~ {.input}
#include <stdio.h>
int main(void){int x;x=1;if(x==1){printf("I am the 
One.\n")};return 0;}
~~~

상기 코드는 앞선 예제와 같지만 화이트스페이스 대부분이 제거되었다. 자바스크립트 같은 스크립팅 언어에 대해, 화이트스페이스를 제거하면 소스코드에 문자 숫자를 줄여서 사용자 웹브라우져에서 실행되는 코드를 다운로드하는 시간을 높일 수 있다. (모바일 핸드폰 기기처럼) 작은 파이프를 경유하여 전달되어야 되는 복잡한 웹 응용 프로그램을 작성하려는 프로그래머에 있어서 속도와 관련된 모든 비트가 도움이 된다.

### 빌딩, 링킹, 패키징



<img src="fig/fig-2-1-computer-system-architecture.png" width="70%" alt="그림 2.2 컴퓨터 시스템 아키텍쳐" />
그림 2.1 컴퓨터 시스템 아키텍쳐

<img src="fig/fig-2-2-interaction-of-the-elements.png" width="70%" alt="컴퓨터 시스템 구성요소 사이 대화" />
그림 2.2 컴퓨터 시스템 구성요소 사이 대화

<img src="fig/fig-2-3-interaction-of-the-elements-with-virtualization.png" width="70%" alt="가상화 계층을 갖는 컴퓨터 시스템 구성요소 사이 대화" />
그림 2.3 가상화 계층을 갖는 컴퓨터 시스템 구성요소 사이 대화





