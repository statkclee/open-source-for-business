---
layout: page
title: 비즈니스를 위한 오픈 소스 소프트웨어
subtitle: 서문
---

근래에 들어서, 오픈소스 소프트웨어가 무엇인지 설명할 필요는 없다. 한때 이상하게 꼬인 소프트웨어 라이선스로 간주되던 것이 이제는 전체 소프트웨어에 대한 튼튼한 기반이 되었다. 이 책을 골랐다면, 아마도 오픈소스 라이선스가 동작하는 방식과 관련된 위험을 책임있는 방식으로 관리하여 비즈니스에 오픈소스 소프트웨어를 사용하고자 할 것이다. 아마도 "LAMP 스택"으로 불리는 리눅스(Linux) 커널, 아파치(Apache) 웹서버, MySQL 데이터베이스, PHP 스크립팅 언어 뿐만 아니라 파이어폭스 웹브라우져 혹은 Sendmail 같은 범용 오픈소스 "킬러 앱(Killer App)"에 친숙할 것이다. 오픈소스 라이선스는 자신만의 고유한 규칙과 관습을 간직하고 있으며 현실 세계에서 주요한 자리를 점하고 있다. 오픈소스 소프트웨어는 전자상거래의 등뼈이며 개발 도상국에서 찾는 소프트웨어 도구상자다. 

이책은 기술 비즈니스에서 생긴 오픈소스 법률적 쟁점사항에 대한 거의 20년에 걸친 결과물이다. 오픈소스 라이선스를 둘러싼 법률적 쟁점사항을 이해하려는 변호사와 사업가를 위한 실무지침서로 집필되었다. 이책은 법률 논문이 아니다; 변호사와 함께 변호사가 무슨 말을 하고 있는지 이해하려는 사람을 돕고자 이책을 집필했다. 기술변호사는 기술이 항상 앞서고, 법률입법자와 판사가 뒤따라, 새로운 패러다임과 능력에 대한 규칙을 정상화하려는 것을 잘 알고 있다. 하지만, 오픈소스 라이선스 경우에, 자리잡은 법률과 모범사례(best practice) 사이에 불일치가 천양지차다. 이것이 왜 리처드 스톨만(Richard Stallman) 같은 오픈소스 라이선스 모형의 주창자가 변호사가 아니고 기술자인 이유다; 기술자는 법률 문화가 따라오길 기다릴 수 없어서 스스로 규칙을 발명할 수 밖에 없었다. 법규와 판례를 정독하면 오픈소스 라이선스를 이해하는데 도움이 될 수는 있지만, 오픈소스 소프트웨어를 사용하는 것에 대한 실무적인 사업결정을 내리는 방법을 이해하려면, 판래집에 없는 상당한 지식과 정보가 필요하다. 

 
오픈소스 소프트웨어가 흥분되고 예측불가능한 사춘기와 마추침에 따라 21세기 십대로 진입하고 있다는 것이 적절할 것이다. 이번 십년은 오픈소스 소프트웨어 라이선스 허가권을 갖는 사람에 의한 첫번째 심대한 집행노력을 목도했다. 따라서 새로운 세대의 여명이 밝았다. 오늘날, 오픈소스는 당연히 있어야 하고, 이익을 창출하는 사업에서 책임감을 갖고 오픈소스를 사용하려면 관리해야되는 실제적 법률위험이 존재하고, 기술 라이선싱을 이해하려는 누구나 오픈소스 라이선싱을 지각해야 한다는 점을 기술에 있는 어떤 누구도도 부인하지 않는다. 특허 라이선스 울타리가 있는 정원(walled garden)은 더이상 가능하지 않다. 오픈소스 소프트웨어는 울타리가 쳐진 정원의 틈을 비집고 자라는 강인한 잡초다.

### 배경지식: 유닉스, 리눅스, 그리고 소프트웨어 라이선스

소프트웨어 라이선스가 시작된 이래로, 오픈소스 소프트웨어 라이선스의 도입은 소프트웨어 라이선스에 있어 가장 괄목할만한 발전이다. 하지만, 소프트웨어 라이선스는 그 자체로 우리와 그다지 오랜기간 함께 지낸 것은 아니다. 실은, 오프소스 라이선스는 사람 대부분이 인식하는 보다 오랜기간 존재해왔다. 사실, 오픈소스 라이선스가 소프트웨어 라이선스에 대한 최초 모형이고, 독점적(proprietary) 라이선스가 굴러들어온 돌이다. 이 두 모형이 함께 어떻게 발전했는지 이해하려면, 컴퓨팅 역사에 대해 이해가 필요하다.

### 아주 오래전에 유닉스라고 불리는 운영체제가 있었다.

대부분 사람들이 "오픈소스"를 언급할 때, 소프트웨어 라이선스 집합을 지칭한다. 이런 라이선스는 사용권을 주는 누군가가 소프트웨어 사용에 대한 이용약관을 정했다. 이런 의미에서, 오픈소스는 라이선싱 모형(Licensing Model)이다. 하지만 또한, 아마도 좀더 중요하게 오픈소스는 소프트웨어 개발에 대한 모형이기도 하다. 차이가 중요한데 이유는 라이선싱 모형과 개발모형이 연관된 위험이 매우 다르기 때문이다.

오픈소스 "킬러앱(Killer App)"의 대표적인 사례가 리눅스 운영체제다. 리눅스가 왜 그리고 어떻게 개발되었는지 학습하는 것이 현재 "오픈소스"로 알고 있는 라이선싱 모형이 어떻게 개발되는지 그리고, 어떻게 오픈소스 모형이 독점적 모형과 다른지 이해하는 최선의 방식이다.

오늘날 기술사업에 종사하는 대부분의 사람들은 윈도우 시대에서 자라나서, 또다른 운영체제(컴퓨팅 역사에서 중대한 역할을 한 유닉스)에 관해서 그다지 알고 있지 못하다. 유닉스(UNIX)가 "자유 소프트웨어(free software)" 모형이 출현한 이유다. 

컴퓨팅의 초기 시절에, 유닉스가 주도적인 운영체제였다. AT&T 벨연구소에서 개발했다. 그 당시에 AT&T는 지배적인 사업라서 독점금지법의 결과로 법무부와 합의된 양자간 합의된 [법원판결(consent degree)][1]에 묶여 전화사업분야를 제외한 상업적 활동에 참여가 금지된다. 따라서, 최고 가장 똑똑한 AT&T 엔지니어는 AT&T 벨연구소로 불리는 비영리 단체에서 컴퓨터 과학 개발을 수행하게 되었다.

    [1]: "Modification of Final Judgment," August 24, 1982, filed in case 82-0192, *United States of America v. Western Electric Company, Incorporated, and American Telephone and Telegraph Company*, U.S. District Court for the District of Columbia, [http://web.archive.org/web/20060827191354/members.cox.net/hwilkerson/documents/AT&T_Consent_Decree.pdf](http://web.archive.org/web/20060827191354/members.cox.net/hwilkerson/documents/AT&T_Consent_Decree.pdf).

켄톰슨(Ken Thompson)과 데니스 리치(Dennis Ritchie)는 벨연구소 과학자로 컴퓨터 프로그램을 공부한 누구나 그들의 이름을 알고 있다. 그들이 첫번째 범용 운영체제, 유닉스 창시자다. 유닉스를 작성하는 동안에 C 로 불리는 프로그래밍 언어도 발명했다. C는 오늘날 용어로 "저수준(low-level)" 언어로 일컸는 유연하고 강력한 프로그래밍 언어다. 저수준 언어는 프로그래머가 소프트웨어와 하드웨어가 상호작용하는 방법에 대한 고수준 제어를 가능하게 한다. 많은 확장과 개선을 겪었고 C언어에 객체지향을 접목한 C++가 가장 눈에 띄지만, C는 여전히 오늘날에도 흔히 사용된다.

하지만, 양자간 합의된 법원판결이 AT&T가 유닉스를 상업적 제품으로 판매를 금했다. 따라서, 기술 분야 바퀴를 예외적인 방향으로 틀어서, 벨연구소는 유닉스를 변형하고 재배포할 수 있는 조건을 갖는 소스코드형태로 나눠졌다. 벨연구소에서 말하듯이, 만약 무언가를 사랑한다면 자유로이 놓아주라 - 그리고 1970년대 1980년대 컴퓨터 과학자는 유닉스를 사랑했다.

그리고 나서, 양자간 합의된 법원판결이 해제되었고, AT&T는 단지 목적코드형태로만 재배포가 허용된 라이선싱 조건을 갖는 제약된 형태 유닉스 라이선스를 부여하기 시작했다. 이것이 유닉스 "포킹(forking)"의 결과를 가져왔고 다수 호환되지 않는 버젼이 양산되었다. 이전에 변형을 할 수 있고 공유를 즐겼던 사람들이 갑자기 그렇게 할 수 없게 되었다. IBM 컴퓨터에서 잘 돌아가던 유닉스 프로그램이 선마이크로시스템즈(SUN) 유닉스에서는 필히 돌아가지 않게 되었다.

자유 소프트웨어 운동이 직접적인 대응으로 유닉스 포킹으로 일어났는데 독점적 라이선싱에 대한 변화다. 상호호환성 부족보다 컴퓨터 프로그래머가 미워하는 것은 없다 - 특히 운영체제같은 기술 스택 하위 계층에서 발생하는 호환성 문제. 그리고, 일부는 이런 것이 다시 재발하지 못하도록 했다.


그 당시에 "독점적" 소프트웨어는 오늘날처럼 아주 흔한 관례가 아니라는 것을 이해하는 것이 중요하다. 1980년대 저자는 그 당시에 미니컴퓨터라고 불리는던 컴퓨터로 작업했다: PDP, 왕 VS, DEC, 콴텔(Quantel). 그 당시 대부분의 응용 프로그래머와 마찬가지로 저자는 주문형 비즈니스 응용프로그램을 작성했다. 어느날 에그헤드 소프트웨어(Egghead Software) 소매점에 들어가서 진열장에서 구매할 수 있는 회계 소프트웨어를 목격한 것을 기억한다. 가능하리라고 절대로 믿을 수 없었던 것이다. (판매 점원이 다가와서 매킨토쉬 컴퓨터용 프로그램을 구매하면 정말 매킨토시 컴퓨터에서 돌아간다고 구매를 유도했다.) 수년동안 프로그래머였고, 표준화된 소프트웨어 개념은 저자에게는 낯설었다. 그 당시 소프트웨어는 두가지 중 한가지 방식으로 출시되었다 - 구매한 컴퓨터에 판매자가 적재하거나,  시스템 통합회사 즉 OEM 으로 불리는 주문형 맞춤 소프트웨어 개발자가 작성한 소프트웨어다. 그리고 소프트웨어는 항상 소스코드형태로 배송되었다. 왜 그럴까? 마이크로 컴퓨터(IBM PC) 이전에, 바이너리-전용 소프트웨어 배포 모형을 지원하거나 요구할만큼 충분한 표준화가 되어있지 못했다. 회사는 거의 항상 번들형태로 동일한 판매회사로부터 하드웨어와 소프트웨어를 구매했다. 기술지원을 하는 사람들은 소스코드가 필요했고, 기술지원은 해당 컴퓨터, 운영체제, 환경에 특별히 맞춰야 했다. (사실, 1985년경에 저자는 첫번째 기술지원대표과 조우했고, 그 개념에 즐거워했다. 왜냐하면, 프로그래머로서 그 당시까지 저자가 기술지원 작업을 수행하는 사람이었기 때문이다.) 그래서 왜 소스코드와 바이너리를 누군가 쪼갰을까? 저자가 한창 일하던 세계에서는 그다지 인식하지는 못했다. 하지만 곧 상전벽해를 목격하게 된다. 전체 컴퓨팅 세계가 변화하기 시작했다. 몇년 지나서, 마이크로컴퓨터가 일반적인 것이 되었고 바이너리 소프트웨어는 표준이 되었다. 마치 모든 맞춤양복 재단사가 하룻밤 사이 시장에서 퇴출되고 그 빈 자리를 기성복 매장이 점유했다. 그리고 만약 변경이 필요하다면, 소프트웨어에 장착된 라이선스를 위반해야 했다.

### 리눅스: "킬러 앱"

